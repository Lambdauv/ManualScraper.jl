{
    "docs": [
        {
            "location": "/", 
            "text": "ManualScraper.jl\n\n\nA package for scraping instrument manuals to assemble standardized templates of commands and documentation.\n\n\n\n\nInstallation\n\n\n\n\nInstall package \nCHM.jl\n.\n\n\nPkg.clone(\"https://github.com/ajkeller34/ManualScraper.jl.git\")\n\n\n\n\n\n\nUsage\n\n\nThis package is not entirely automated; to do so would require some intelligent parsing that would be far more complicated. Think of this package as a repository for the code that generates the template files read by the \nPainterQB\n package.\n\n\n\n\n\n\nGet a plain-text or HTML file to parse that describes the instrument commands. This may be the hardest part as often times only a PDF file is provided. If the instrument has an on-board Windows computer, it will likely have a .CHM file from which HTML can be retrieved using \nCHM.jl\n. If the instrument only has a PDF file, I've achieved the best results in extracting text using Adobe Acrobat. There are open-source packages to do this but the results are often worse, at least with limited tweaking.\n\n\n\n\n\n\nConstruct a regular expression to peel the required information out of the plain-text or HTML. You will want to extract the commands, argument types, and possibly documentation (although be careful with copyright if sharing). For constructing the regular expressions, it is probably easiest to use an interactive website that shows the results of the regex search as you construct the expression. Just search for \"regular expression tester\" and look for one that supports PCRE regex.\n\n\n\n\n\n\nCollect the information from the regex search into arrays. See existing examples for how to do this.\n\n\n\n\n\n\nUse the \nManualScraper.template\n function to turn the collected information into the desired template file. It is capable of merging information from old versions of template files.\n\n\n\n\n\n\n\n\nAPI\n\n\n#\n\n\nManualScraper.template\n \n \nFunction\n.\n\n\n\n\ntemplate(data, labels, outpath::AbstractString;     insdict=emptyinsdict(),     merge::Bool=true)\n\n\nWrites a JSON file given \ndata\n and \nlabels\n. For example:\n\n\ndata = [(\n:OUTPUT\n, \nv::Bool\n, \n), (\n:OTHERCMD\n, \nv::Symbol\n, \n)]\nlabels = [\ncmd\n, \nvalues\n, \ntype\n]\ntemplate(data, labels, \n/my/path.json\n)\n\n\n\n\n\nOptionally \ninsdict\n can be provided for the \n\"instrument\"\n field of the resulting JSON file, or if not provided a template is included to be filled in later.\n\n\nIf \nmerge\n is true, then the fields of any JSON file at \noutpath\n are retained and only previously undefined fields are added to the file in the corresponding locations. The \ncmd\n field of a property dictionary is used to distinguish different instrument properties. It is recommended to work on a duplicate of the original file.\n\n\n#\n\n\nManualScraper.cmdtostr\n \n \nFunction\n.\n\n\n\n\ncmdtostr(a::AbstractString)\n\n\nReturns a string based on a command, e.g. \":SOURCE:FUNCTION\" becomes \"SourceFunction\".\n\n\n#\n\n\nManualScraper.emptyinsdict\n \n \nFunction\n.\n\n\n\n\nemptyinsdict()\n\n\nReturns a \nDict\n intended to be used in an instrument JSON file for the \"instrument\" dictionary. It has the expected keys and corresponding empty string values.", 
            "title": "Home"
        }, 
        {
            "location": "/#manualscraperjl", 
            "text": "A package for scraping instrument manuals to assemble standardized templates of commands and documentation.", 
            "title": "ManualScraper.jl"
        }, 
        {
            "location": "/#installation", 
            "text": "Install package  CHM.jl .  Pkg.clone(\"https://github.com/ajkeller34/ManualScraper.jl.git\")", 
            "title": "Installation"
        }, 
        {
            "location": "/#usage", 
            "text": "This package is not entirely automated; to do so would require some intelligent parsing that would be far more complicated. Think of this package as a repository for the code that generates the template files read by the  PainterQB  package.    Get a plain-text or HTML file to parse that describes the instrument commands. This may be the hardest part as often times only a PDF file is provided. If the instrument has an on-board Windows computer, it will likely have a .CHM file from which HTML can be retrieved using  CHM.jl . If the instrument only has a PDF file, I've achieved the best results in extracting text using Adobe Acrobat. There are open-source packages to do this but the results are often worse, at least with limited tweaking.    Construct a regular expression to peel the required information out of the plain-text or HTML. You will want to extract the commands, argument types, and possibly documentation (although be careful with copyright if sharing). For constructing the regular expressions, it is probably easiest to use an interactive website that shows the results of the regex search as you construct the expression. Just search for \"regular expression tester\" and look for one that supports PCRE regex.    Collect the information from the regex search into arrays. See existing examples for how to do this.    Use the  ManualScraper.template  function to turn the collected information into the desired template file. It is capable of merging information from old versions of template files.", 
            "title": "Usage"
        }, 
        {
            "location": "/#api", 
            "text": "#  ManualScraper.template     Function .   template(data, labels, outpath::AbstractString;     insdict=emptyinsdict(),     merge::Bool=true)  Writes a JSON file given  data  and  labels . For example:  data = [( :OUTPUT ,  v::Bool ,  ), ( :OTHERCMD ,  v::Symbol ,  )]\nlabels = [ cmd ,  values ,  type ]\ntemplate(data, labels,  /my/path.json )  Optionally  insdict  can be provided for the  \"instrument\"  field of the resulting JSON file, or if not provided a template is included to be filled in later.  If  merge  is true, then the fields of any JSON file at  outpath  are retained and only previously undefined fields are added to the file in the corresponding locations. The  cmd  field of a property dictionary is used to distinguish different instrument properties. It is recommended to work on a duplicate of the original file.  #  ManualScraper.cmdtostr     Function .   cmdtostr(a::AbstractString)  Returns a string based on a command, e.g. \":SOURCE:FUNCTION\" becomes \"SourceFunction\".  #  ManualScraper.emptyinsdict     Function .   emptyinsdict()  Returns a  Dict  intended to be used in an instrument JSON file for the \"instrument\" dictionary. It has the expected keys and corresponding empty string values.", 
            "title": "API"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "The ManualScraper.jl package is licensed under the MIT \"Expat\" License:\n\n\n\n\nCopyright (c) 2016: Andrew Keller.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}