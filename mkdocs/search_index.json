{
    "docs": [
        {
            "location": "/", 
            "text": "ManualScraper.jl\n\n\nA package for scraping instrument manuals to assemble standardized templates of commands and documentation.\n\n\n\n\nInstallation\n\n\n\n\nInstall package \nCHM.jl\n.\n\n\nPkg.clone(\"https://github.com/ajkeller34/ManualScraper.jl.git\")\n\n\n\n\n\n\nUsage\n\n\nThis package is not entirely automated; to do so would require some intelligent parsing that would be far more complicated. Think of this package as a repository for the code that generates the template files read by the \nPainterQB\n package.\n\n\n\n\n\n\nGet a plain-text or HTML file to parse that describes the instrument commands. This may be the hardest part as often times only a PDF file is provided. If the instrument has an on-board Windows computer, it will likely have a .CHM file from which HTML can be retrieved using \nCHM.jl\n. If the instrument only has a PDF file, I've achieved the best results in extracting text using Adobe Acrobat. There are open-source packages to do this but the results are often worse, at least with limited tweaking.\n\n\n\n\n\n\nConstruct regular expressions to peel the required information out of the plain-text, HTML, etc. You will want to extract the commands, argument types, and possibly documentation (although be careful with copyright if sharing). For constructing the regular expressions, it is probably easiest to use an interactive website that shows the results of the regex search as you construct the expression. Just search for \"regular expression tester\" and look for one that supports PCRE regex.\n\n\n\n\n\n\nCollect the information from the regex search into arrays. See existing examples for how to do this.\n\n\n\n\n\n\nUse the \nManualScraper.template\n function to turn the collected information into the desired template file. It is capable of merging information from old versions of template files.\n\n\n\n\n\n\n\n\nAPI\n\n\n\n\nMacros\n\n\n#\n\n\nManualScraper.@awg5k_str\n \n \nMacro\n.\n\n\n\n\n@awg5k_str(path)\n\n\nString macro. Given a path to the Tektronix AWG5000 series' .chm file, construct a \nCHMSource\n that contains information on how to parse the .chm file.\n\n\nUsage: \nsrc = awg5k\"/path/to/file.chm\"\n\n\nWhen entering a file path using this macro, do not escape spaces in the path.\n\n\n#\n\n\nManualScraper.@ena_str\n \n \nMacro\n.\n\n\n\n\n@ena_str(path)\n\n\nString macro. Given a path to the Keysight ENA's .chm file, construct a \nCHMSource\n that contains information on how to parse the .chm file.\n\n\nUsage: \nsrc = ena\"/path/to/file.chm\"\n\n\nWhen entering a file path using this macro, do not escape spaces in the path.\n\n\n\n\nInternal\n\n\n#\n\n\nManualScraper.cmdtostr\n \n \nFunction\n.\n\n\n\n\ncmdtostr(a::AbstractString)\n\n\nReturns a string based on a command, e.g. \":SOURCE:FUNCTION\" becomes \"SourceFunction\".\n\n\n#\n\n\nManualScraper.diagnose\n \n \nFunction\n.\n\n\n\n\ndiagnose(text)\n\n\nSets up an interactive prompt for diagnosing issues with files that are not correctly parsed by the given regular expressions. This is called e.g. whenever a .chm file is scraped, not directly by the user.\n\n\n#\n\n\nManualScraper.emptyinsdict\n \n \nFunction\n.\n\n\n\n\nemptyinsdict()\n\n\nReturns a \nDict\n intended to be used in an instrument JSON file for the \"instrument\" dictionary. It has the expected keys and corresponding empty string values.\n\n\n#\n\n\nManualScraper.template\n \n \nFunction\n.\n\n\n\n\ntemplate(data, labels, ids, outpath::AbstractString;     insdict=emptyinsdict(),     merge::Bool=true)\n\n\nWrites a JSON file given \ndata\n and \nlabels\n. For example:\n\n\ndata = [(\n:OUTPUT\n, \nv::Bool\n, \n), (\n:OTHERCMD\n, \nv::Symbol\n, \n)]\nlabels = [\ncmd\n, \nvalues\n, \ntype\n]\ntemplate(data, labels, 1:2, \n/my/path.json\n)\n\n\n\n\n\nOptionally \ninsdict\n can be provided for the \n\"instrument\"\n field of the resulting JSON file, or if not provided a template is included to be filled in later.\n\n\nIf \nmerge\n is true, then the \"type\" and symbol fields of a JSON file at \noutpath\n are retained for a given \ncmd\n. The \ncmd\n field of a property dictionary is used to distinguish different instrument properties. The user is prompted to advise how to proceed if a new command is found that wasn't at \noutpath\n, and also if multiple entries are found with the same \ncmd\n field. It is recommended to work on a duplicate of the original file.\n\n\n#\n\n\nManualScraper.upperfirst\n \n \nFunction\n.\n\n\n\n\nupperfirst(a::AbstractString)\n\n\nReturns a string based on \na\n with the first character only in uppercase.", 
            "title": "Home"
        }, 
        {
            "location": "/#manualscraperjl", 
            "text": "A package for scraping instrument manuals to assemble standardized templates of commands and documentation.", 
            "title": "ManualScraper.jl"
        }, 
        {
            "location": "/#installation", 
            "text": "Install package  CHM.jl .  Pkg.clone(\"https://github.com/ajkeller34/ManualScraper.jl.git\")", 
            "title": "Installation"
        }, 
        {
            "location": "/#usage", 
            "text": "This package is not entirely automated; to do so would require some intelligent parsing that would be far more complicated. Think of this package as a repository for the code that generates the template files read by the  PainterQB  package.    Get a plain-text or HTML file to parse that describes the instrument commands. This may be the hardest part as often times only a PDF file is provided. If the instrument has an on-board Windows computer, it will likely have a .CHM file from which HTML can be retrieved using  CHM.jl . If the instrument only has a PDF file, I've achieved the best results in extracting text using Adobe Acrobat. There are open-source packages to do this but the results are often worse, at least with limited tweaking.    Construct regular expressions to peel the required information out of the plain-text, HTML, etc. You will want to extract the commands, argument types, and possibly documentation (although be careful with copyright if sharing). For constructing the regular expressions, it is probably easiest to use an interactive website that shows the results of the regex search as you construct the expression. Just search for \"regular expression tester\" and look for one that supports PCRE regex.    Collect the information from the regex search into arrays. See existing examples for how to do this.    Use the  ManualScraper.template  function to turn the collected information into the desired template file. It is capable of merging information from old versions of template files.", 
            "title": "Usage"
        }, 
        {
            "location": "/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/#macros", 
            "text": "#  ManualScraper.@awg5k_str     Macro .   @awg5k_str(path)  String macro. Given a path to the Tektronix AWG5000 series' .chm file, construct a  CHMSource  that contains information on how to parse the .chm file.  Usage:  src = awg5k\"/path/to/file.chm\"  When entering a file path using this macro, do not escape spaces in the path.  #  ManualScraper.@ena_str     Macro .   @ena_str(path)  String macro. Given a path to the Keysight ENA's .chm file, construct a  CHMSource  that contains information on how to parse the .chm file.  Usage:  src = ena\"/path/to/file.chm\"  When entering a file path using this macro, do not escape spaces in the path.", 
            "title": "Macros"
        }, 
        {
            "location": "/#internal", 
            "text": "#  ManualScraper.cmdtostr     Function .   cmdtostr(a::AbstractString)  Returns a string based on a command, e.g. \":SOURCE:FUNCTION\" becomes \"SourceFunction\".  #  ManualScraper.diagnose     Function .   diagnose(text)  Sets up an interactive prompt for diagnosing issues with files that are not correctly parsed by the given regular expressions. This is called e.g. whenever a .chm file is scraped, not directly by the user.  #  ManualScraper.emptyinsdict     Function .   emptyinsdict()  Returns a  Dict  intended to be used in an instrument JSON file for the \"instrument\" dictionary. It has the expected keys and corresponding empty string values.  #  ManualScraper.template     Function .   template(data, labels, ids, outpath::AbstractString;     insdict=emptyinsdict(),     merge::Bool=true)  Writes a JSON file given  data  and  labels . For example:  data = [( :OUTPUT ,  v::Bool ,  ), ( :OTHERCMD ,  v::Symbol ,  )]\nlabels = [ cmd ,  values ,  type ]\ntemplate(data, labels, 1:2,  /my/path.json )  Optionally  insdict  can be provided for the  \"instrument\"  field of the resulting JSON file, or if not provided a template is included to be filled in later.  If  merge  is true, then the \"type\" and symbol fields of a JSON file at  outpath  are retained for a given  cmd . The  cmd  field of a property dictionary is used to distinguish different instrument properties. The user is prompted to advise how to proceed if a new command is found that wasn't at  outpath , and also if multiple entries are found with the same  cmd  field. It is recommended to work on a duplicate of the original file.  #  ManualScraper.upperfirst     Function .   upperfirst(a::AbstractString)  Returns a string based on  a  with the first character only in uppercase.", 
            "title": "Internal"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "The ManualScraper.jl package is licensed under the MIT \"Expat\" License:\n\n\n\n\nCopyright (c) 2016: Andrew Keller.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}